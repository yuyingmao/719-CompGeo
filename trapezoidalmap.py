import sys

"""
Point: defines a 2d point
    Parameter(s)
        x:  an int or a float represents x-coordinate value
        y:  an int or a float represents y-coordinate value
        flag:   indicate type of point it is
            P:  left endpoint
            Q:  right endpoint
"""
class Point:
    def __init__(self,x,y,flag):
        self.x=x
        self.y=y
        self.flag=flag

    def __eq__(self,p2):
        return self.x==p2.x and self.y==p2.y

    def __lt__(self,p2):
        if self.x<p2.x:
            return True
        elif self.x==p2.x:
            return self.y<p2.y
        return False
    
    def __gt__(self,p2):
        if self.x>p2.x:
            return True
        elif self.x==p2.x:
            return self.y>p2.y
        return False

    def __hash__(self):
        return hash(self.x+self.y)

"""
LineSegment: Defines a line segment
    Parameter(s)
        start:  left endpoint of this line segment
        end:    right endpoint of this line segment
        m:  slope of this line segment equation
        b:  b of this line segment equation
"""
class LineSegment:
    def __init__(self,leftEndPoint,rightEndPoint):
        self.start=leftEndPoint
        self.end=rightEndPoint
        self.m=(leftEndPoint.y-rightEndPoint.y)/(leftEndPoint.x-rightEndPoint.x)
        self.b=leftEndPoint.y-self.m*leftEndPoint.x
    
    def __eq__(self,ls2):
        return self.start==ls2.start and self.end==ls2.end

"""
Wall: Defines a vertical line represents the wall created by endpoints
    Parameter(s)
        x:  x-coordinate value of this vertical line
        ys: y-coordinate value indicates the position of the point
        yi: the minimum y value this wall reaches
        ya: the maximum y value this wall reaches
"""
class Wall:
    def __init__(self,x,yStart,yMin,yMax):
        self.x=x
        self.ys=yStart
        self.yi=yMin
        self.ya=yMax
    
    def __eq__(self,w2):
        return self.x==w2.x
    
    def __lt__(self,w2):
        return self.x<w2.x
    
    def __gt__(self,w2):
        return self.x>w2.x

"""
Cell: Defines the trapezoid
    Parameter(s)
        left:   left boundary, can be either a Wall or a number(means the bounding box edge)
        right:  right boundary, can be either a Wall or a number(means the bounding box edge)
        above:  above boundary, can be either a line segment or a number(means the bounding box edge)
        below:  below boundary, can be either a line segment or a number(means the bounding box edge)
"""
class Cell:
    def __init__(self,leftBoundary,rightBoundary,aboveBoundary,belowBoundary):
        self.left=leftBoundary
        self.right=rightBoundary
        self.above=aboveBoundary
        self.below=belowBoundary
    
    def __eq__(self,c2):
        return self.left==c2.left and self.right==c2.right and self.above==c2.above and self.below==c2.below

"""
DAG: Defines a directed acyclic graph
    Parameter(s)
        leftChild:  left child of current node (or above child for LineSegment; None for Cell)
        itself: the actual object in this node, can be Point, LineSegment, or Cell
        rightChild: right child of current node (or below child for LineSegment; None for Cell)
"""
class DAG:
    def __init__(self,leftChild,current,rightChild):
        self.leftChild=leftChild
        self.itself=current
        self.rightChild=rightChild

"""
pointLocate: finds the trapezoid a point is located
    Parameter(s):
        p:  point
        node: current DAG node
"""
def pointLocate(p,node):
    #if current node is a Cell, return
    if isinstance(node.itself,Cell):
        return node
    #else if current node is a Point, search through its left or right child
    elif isinstance(node.itself,Point):
        if p<node.itself:
            pointLocate(p,node.leftChild)
        else:
            pointLocate(p,node.rightChild)
    #else if current node is a LineSegment, search through its above or below child
    elif isinstance(node.itself,LineSegment):
        y=node.itself.m*p.x+node.itself.b
        if p.y<y:
            pointLocate(p,node.rightChild)
        else:
            pointLocate(p,node.leftChild)

"""
wallCreate: creates walls generated by the endpoints of a line segment
"""
def wallCreate(pCell,qCell,p,q):
    #check left endpoint's wall's lower boundaries
    if isinstance(pCell.below,float):
        pyMin=pCell.below
    elif isinstance(pCell.below,LineSegment):
        pyMin=pCell.below.m*p.x+pCell.below.b
    #check end endpoint's wall's lower boundaries
    if isinstance(qCell.below,float):
        qyMin=qCell.below
    elif isinstance(qCell.below,LineSegment):
        qyMin=qCell.below.m*q.x+qCell.below.b

    #check left endpoint's wall's upper boundaries
    if isinstance(pCell.above,float):
        pyMax=pCell.above
    elif isinstance(pCell.above,LineSegment):
        pyMax=pCell.above.m*p.x+pCell.above.b
    #check right endpoint's wall's upper boundaries
    if isinstance(qCell.above,float):
        qyMax=qCell.above
    elif isinstance(qCell.above,LineSegment):
        qyMax=qCell.above.m*q.x+qCell.above.b

    #create two walls
    return Wall(p.x,p.y,pyMin,pyMax),Wall(q.x,q.y,qyMin,qyMax)

"""
trimWalls: trim back the wall(s) if the new line segment has cutted through it
    Parameter(s):
        ls: the line segment
        walls:  a list of current walls
    Return:
        a list of walls that have been trimmed back
"""
def trimWalls(ls,walls):
    modifiedWalls=[]
    for i in range(len(walls)):
        currWall=walls[i]
        if currWall.x>ls.start.x and currWall.x<ls.end.x:
            currY=ls.m*currWall.x+ls.b
            if currY>currWall.ys and currY<currWall.ya:   #trim above
                currWall.ya=currY
                modifiedWalls.append(currWall)
            elif currY<currWall.ys and currY>currWall.yi: #trim below
                currWall.yi=currY
                modifiedWalls.append(currWall)
    return modifiedWalls
            
"""
buildTrapezoidalMap: uses randomized incremental algorithm to build the trapezoidal map
    Parameter(s)
        lineSegments:   a list of line segements
        dag:    the root of DAG
        cells:  a list of valid cells
"""
def buildTrapezoidalMap(lineSegments,dag,cells):
    walls=[]
    for ls in lineSegments:
        p=ls.start
        q=ls.end
        #find the cells p and q are located
        pNode=pointLocate(p,dag)
        qNode=pointLocate(q,dag)
        pCell=pNode.itself
        qCell=qNode.itself
        #create and add walls
        pWall,qWall=wallCreate(pCell,qCell,p,q)
        walls.append(pWall)
        walls.append(qWall)
        walls=sorted(walls) #sort the walls based on their x values

        #case #2: both endpoints are inside the same cell
        if pCell==qCell:
            #remove the current cell
            cells.remove(pCell)
            #create new cells
            aCell=Cell(pCell.left,pWall,pCell.above,pCell.below)
            bCell=Cell(pWall,qWall,pCell.above,ls)
            cCell=Cell(pWall,qWall,ls,pCell.below)
            dCell=Cell(qWall,pCell.right,pCell.above,pCell.below)
            cells.append(aCell)
            cells.append(bCell)
            cells.append(cCell)
            cells.append(dCell)
            
            #update maps
            sNewNode=DAG(DAG(None,bCell,None),ls,DAG(None,cCell,None))
            pNode.itself=p
            pNode.leftChild=DAG(None,aCell,None)
            pNode.rightChild=DAG(sNewNode,q,DAG(None,dCell,None))
        
        #case 1&3: the line segment sets across different cells
        else:
            #trim back the walls
            modifiedWalls=trimWalls(ls,walls)
            #TODO remove old cells and generate new cells after trimming

            #TODO case #1: endpoints are inside differnt cells

            #TODO case #3: the line segment cuts through cell(s) completely 
            if pCell.right!=qCell.left:
                pass
            pass


def main():
    inputfile=open("1.txt",'r')
    inputfile.readline()    #ignore number of line segments

    #get bounding box
    line=inputfile.readline().split()
    xMin=float(line[0])
    yMin=float(line[1])
    xMax=float(line[2])
    yMax=float(line[3])

    #intialize trapezoidal map
    cells=[]
    initialCell=Cell(xMin,xMax,yMax,yMin)
    cells.append(initialCell)
    dag=DAG(None,initialCell,None)

    #get points and line segments
    points=set()
    lineSegments=[]
    while True:
        line=inputfile.readline().split()
        if not line:
            break
        if float(line[0])<=float(line[2]):
            start=Point(float(line[0]),float(line[1]),'P')
            end=Point(float(line[2]),float(line[3]),'Q')
        else:
            start=Point(float(line[2]),float(line[3]),'P')
            end=Point(float(line[0]),float(line[1]),'Q')
        points.add(start)
        points.add(end)
        lineSegments.append(LineSegment(start,end))
    inputfile.close()

    buildTrapezoidalMap(lineSegments,dag,cells)
    #TODO print out the required matrix

    #TODO ask user to input a point and call pointLocate to find its cell

if __name__ == "__main__":
    main()